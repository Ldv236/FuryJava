package ru.ldv236.patterns.other.callBack;

public class Main {
    public static void main(String[] args) {
        // Создаем экземпляр TaskExecutor
        TaskExecutor executor = new TaskExecutor();

        // Передаем экземпляр интерфейса TaskListener как колбэк
        executor.executeTask(new TaskListener() {
            @Override
            public void onTaskCompleted() {
                // Этот метод будет вызван по завершении задачи
                System.out.println("Callback: Task completed successfully!");
            }
        });

        // Передаем колбэк с помощью лямбда-выражения, если интерфейс функциональный
        executor.executeTask(() -> {
            System.out.println("Callback: Task completed with lambda!");
        });
    }
//    5. Когда и зачем используются интерфейсы обратного вызова
//    Интерфейсы обратного вызова полезны в следующих случаях:
//    Асинхронные операции: Когда необходимо выполнять длительные задачи (например, загрузка данных, обработка файлов, сетевые запросы) и уведомлять о завершении.
//    Событийное программирование: Когда необходимо реагировать на определенные события (например, нажатия кнопок в GUI, завершение транзакций).
//    Передача поведения: Вы можете гибко передавать логику выполнения через колбэки, что делает программу более гибкой и адаптируемой к разным сценариям.
//    Разделение обязанностей: Колбэки помогают разделить ответственность за выполнение задачи и за обработку результата, что способствует лучшей модульности кода.

//6. Преимущества использования интерфейсов обратного вызова
//    Гибкость: Колбэки позволяют изменять поведение программы, передавая различные реализации интерфейсов в зависимости от ситуации.
//    Асинхронность: Интерфейсы обратного вызова часто используются в асинхронных операциях, позволяя системе не блокировать основной поток выполнения.
//    Модульность и инкапсуляция: Код, отвечающий за выполнение задачи, отделен от кода, который реагирует на результат задачи.

//    Заключение
//    Когда говорят "методу передается экземпляр интерфейса обратного вызова", это означает, что метод принимает объект,
//    реализующий интерфейс, который будет вызван в будущем для выполнения какого-то действия.
//    Это мощная техника для работы с асинхронными задачами и событийным программированием, позволяющая передавать
//    поведение между частями кода.
//    В современных Java-программах часто используется функциональные интерфейсы и лямбда-выражения для упрощения работы с колбэками.
}
